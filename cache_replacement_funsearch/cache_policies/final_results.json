{
  "generations": [
    [
      "pc_boldest",
      "adaptive_reuse",
      "adaptive_phoenix",
      "pc_lru",
      "lru_aura"
    ],
    [
      "hybrid_adaptive_lru",
      "hybrid_adaptive_lru",
      "lru_adaptive_frequency",
      "hybrid_recency_frequency",
      "hybridreuse"
    ],
    [
      "frec",
      "lru_aging",
      "swbok",
      "frequent_lru",
      "lru_frequency"
    ]
  ],
  "policies": {
    "lru_reference": {
      "name": "lru_reference",
      "code": "\n#include \"lru_reference.h\"\n\n#include <algorithm>\n#include <cassert>\n\nlru_reference::lru_reference(CACHE* cache) : lru_reference(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nlru_reference::lru_reference(CACHE* cache, long sets, long ways) : replacement(cache), NUM_WAY(ways), last_used_cycles(static_cast<std::size_t>(sets * ways), 0) {}\n\nlong lru_reference::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set, champsim::address ip,\n                      champsim::address full_addr, access_type type)\n{\n  auto begin = std::next(std::begin(last_used_cycles), set * NUM_WAY);\n  auto end = std::next(begin, NUM_WAY);\n\n  // Find the way whose last use cycle is most distant\n  auto victim = std::min_element(begin, end);\n  assert(begin <= victim);\n  assert(victim < end);\n  return std::distance(begin, victim);\n}\n\nvoid lru_reference::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip, champsim::address victim_addr,\n                                 access_type type)\n{\n  // Mark the way as being used on the current cycle\n  last_used_cycles.at((std::size_t)(set * NUM_WAY + way)) = cycle++;\n}\n\nvoid lru_reference::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip,\n                                   champsim::address victim_addr, access_type type, uint8_t hit)\n{\n  // Mark the way as being used on the current cycle\n  if (hit && access_type{type} != access_type::WRITE) // Skip this for writeback hits\n    last_used_cycles.at((std::size_t)(set * NUM_WAY + way)) = cycle++;\n}\n",
      "fitness": -3148.93483,
      "parent_policies": [],
      "compilation_success": true,
      "metrics": {
        "avg_mpki": 3149.0,
        "avg_ipc": 0.6517,
        "traces": {
          "astar_163B.trace.xz": {
            "mpki": 3149,
            "ipc": 0.6517
          }
        }
      }
    },
    "pc_boldest": {
      "name": "pc_boldest",
      "code": "#include \"pc_boldest.h\"\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n\npc_boldest::pc_boldest(CACHE* cache) : pc_boldest(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\npc_boldest::pc_boldest(CACHE* cache, long sets, long ways) : replacement(cache), NUM_WAY(ways), \n  pc_usage(sets, std::vector<uint64_t>(ways, 0)),\n  temporal_boldness(sets, std::vector<uint64_t>(ways, 0)),\n  spatial_boldness(sets, std::vector<uint64_t>(ways, 0))\n{\n}\n\nlong pc_boldest::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set, champsim::address ip,\n                      champsim::address full_addr, access_type type)\n{\n  auto pc = ip.get_pc();\n  \n  // Calculate victim score based on PC usage, temporal boldness, and spatial boldness\n  auto begin = std::next(std::begin(pc_usage), set * NUM_WAY);\n  auto end = std::next(begin, NUM_WAY);\n  \n  // Combine metrics to find the least useful block\n  auto victim = std::min_element(begin, end, \n    [=](const std::tuple<uint64_t, uint64_t, uint64_t>& a, const std::tuple<uint64_t, uint64_t, uint64_t>& b) {\n      return (std::get<0>(a) + std::get<1>(a) + std::get<2>(a)) < \n             (std::get<0>(b) + std::get<1>(b) + std::get<2>(b));\n    });\n  \n  assert(begin <= victim);\n  assert(victim < end);\n  return std::distance(begin, victim);\n}\n\nvoid pc_boldest::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip,\n                                 champsim::address victim_addr, access_type type)\n{\n  auto pc = ip.get_pc();\n  pc_usage.at(set * NUM_WAY + way) = cycle++;\n}\n\nvoid pc_boldest::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip,\n                                   champsim::address victim_addr, access_type type, uint8_t hit)\n{\n  if (hit && access_type{type} != access_type::WRITE) {\n    auto pc = ip.get_pc();\n    \n    // Update temporal boldness based on recency\n    temporal_boldness[set][way] = (cycle - temporal_boldness[set][way] < TEMPORAL_THRESHOLD) ? \n                                temporal_boldness[set][way] + 1 : 0;\n    \n    // Update spatial boldness based on PC proximity\n    spatial_boldness[set][way] = (pc.get_offset() - spatial_boldness[set][way]) < 0x100 ? \n                                spatial_boldness[set][way] + 1 : 0;\n    \n    // Update PC usage\n    pc_usage[set][way] = cycle++;\n  }\n}\n",
      "fitness": -Infinity,
      "parent_policies": [],
      "compilation_success": false,
      "metrics": {}
    },
    "adaptive_reuse": {
      "name": "adaptive_reuse",
      "code": "#include \"adaptive_reuse.h\"\n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nadaptive_reuse::adaptive_reuse(CACHE* cache) : adaptive_reuse(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nadaptive_reuse::adaptive_reuse(CACHE* cache, long sets, long ways) : replacement(cache), NUM_WAY(ways),\n  last_used_cycles(static_cast<std::size_t>(sets * ways), 0),\n  frequency(static_cast<std::size_t>(sets * ways), 0),\n  pc_histogram(static_cast<std::size_t>(sets * ways), 0),\n  utility_score(static_cast<std::size_t>(sets * ways), 0),\n  backup_way(static_cast<std::size_t>(sets), -1) {}\n\nlong adaptive_reuse::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set,\n                                champsim::address ip, champsim::address full_addr, access_type type) {\n  const auto begin = std::next(std::begin(utility_score), set * NUM_WAY);\n  const auto end = std::next(begin, NUM_WAY);\n\n  // Calculate utility scores for each way in the set\n  for (auto it = begin; it != end; ++it) {\n    const auto index = std::distance(std::begin(utility_score), it);\n    const auto recency = cycle - last_used_cycles[index];\n    const auto inv_recency = static_cast<double>(recency) * 0.1; // Inverse relation\n    const auto inv_frequency = static_cast<double>(1.0 / (frequency[index] + 1));\n    const auto pc_weight = static_cast<double>(1.0 / (pc_histogram[index] + 1));\n    *it = static_cast<uint64_t>(inv_recency + inv_frequency + pc_weight);\n  }\n\n  const auto victim = std::min_element(begin, end);\n  assert(begin <= victim);\n  assert(victim < end);\n  return std::distance(begin, victim);\n}\n\nvoid adaptive_reuse::replacement_cache_fill(uint32_t triggering_cpu, long set, long way,\n                                            champsim::address full_addr, champsim::address ip,\n                                            champsim::address victim_addr, access_type type) {\n  const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n  last_used_cycles[index] = cycle++;\n  frequency[index]++;\n  pc_histogram[index]++;\n  utility_score[index] = 0; // Reset utility score\n}\n\nvoid adaptive_reuse::update_replacement_state(uint32_t triggering_cpu, long set, long way,\n                                             champsim::address full_addr, champsim::address ip,\n                                             champsim::address victim_addr, access_type type, uint8_t hit) {\n  if (hit && access_type{type} != access_type::WRITE) { // Skip for writeback hits\n    const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n    last_used_cycles[index] = cycle++;\n    frequency[index]++;\n    pc_histogram[index]++;\n    utility_score[index] = 0; // Reset utility score\n  }\n}\n",
      "fitness": -3148.93483,
      "parent_policies": [],
      "compilation_success": true,
      "metrics": {
        "avg_mpki": 3149.0,
        "avg_ipc": 0.6517,
        "traces": {
          "astar_163B.trace.xz": {
            "mpki": 3149,
            "ipc": 0.6517
          }
        }
      }
    },
    "adaptive_phoenix": {
      "name": "adaptive_phoenix",
      "code": "#include \"adaptive_phoenix.h\"\n#include <algorithm>\n#include <cassert>\n\nadaptive_phoenix::adaptive_phoenix(CACHE* cache) : adaptive_phoenix(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nadaptive_phoenix::adaptive_phoenix(CACHE* cache, long sets, long ways) : \n    replacement(cache), \n    NUM_WAY(ways), \n    last_used_cycles(static_cast<std::size_t>(sets * ways), 0),\n    pc_history(static_cast<std::size_t>(sets * ways), 0),\n    access_pattern(static_cast<std::size_t>(sets * ways), 0),\n    bypass_candidate(static_cast<std::size_t>(sets * ways), false),\n    victim_cache(static_cast<std::size_t>(sets), 0),\n    set_conflicts(static_cast<std::size_t>(sets), 0) \n{\n    // Initialize victim cache with invalid addresses\n    std::fill(victim_cache.begin(), victim_cache.end(), (uint64_t)-1);\n}\n\nlong adaptive_phoenix::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set,\n                          champsim::address ip, champsim::address full_addr, access_type type)\n{\n    // Calculate start and end indices for the current set\n    auto begin = std::next(std::begin(last_used_cycles), set * NUM_WAY);\n    auto end = std::next(begin, NUM_WAY);\n    \n    // Find the best victim candidate based on multiple criteria\n    long victim_way = -1;\n    uint64_t max_score = 0;\n    \n    // Iterate through each way in the set\n    for (long way = 0; way < NUM_WAY; ++way) {\n        auto idx = begin + way;\n        \n        // Calculate the score based on:\n        // 1. Recency of use (lower cycle is better)\n        // 2. PC distance (if same PC, higher priority)\n        // 3. Access pattern (sequential vs random)\n        // 4. Bypass candidate status\n        uint64_t score = last_used_cycles[idx];\n        \n        // Apply PC-based promotion if same program counter\n        if (pc_history[idx] == ip) {\n            score = std::max(score, cycle); // Promote to most recently used\n        }\n        \n        // Demote blocks with sequential access patterns\n        if (access_pattern[idx] == access_type::READ && \n            (instr_id - pc_history[idx]) > 32) {\n            score = std::min(score, 0); // Demote if sequential access\n        }\n        \n        // Bypass low-utility blocks\n        if (bypass_candidate[idx]) {\n            score = std::max(score, cycle); // Prioritize bypass candidates\n        }\n        \n        // Track victim blocks in victim cache\n        if (score > max_score) {\n            max_score = score;\n            victim_way = way;\n        }\n    }\n    \n    // Update victim cache with evicted blocks\n    if (victim_way != -1) {\n        victim_cache[set] = current_set[victim_way].address;\n    }\n    \n    return victim_way;\n}\n\nvoid adaptive_phoenix::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, \n                                  champsim::address full_addr, champsim::address ip,\n                                  champsim::address victim_addr, access_type type)\n{\n    // Update metadata for the filled block\n    auto idx = static_cast<std::size_t>(set * NUM_WAY + way);\n    last_used_cycles[idx] = cycle++;\n    pc_history[idx] = ip;\n    access_pattern[idx] = static_cast<uint64_t>(type);\n    bypass_candidate[idx] = false;\n}\n\nvoid adaptive_phoenix::update_replacement_state(uint32_t triggering_cpu, long set, long way,\n                                      champsim::address full_addr, champsim::address ip,\n                                      champsim::address victim_addr, access_type type,\n                                      uint8_t hit)\n{\n    if (hit && type != access_type::WRITE) {\n        auto idx = static_cast<std::size_t>(set * NUM_WAY + way);\n        last_used_cycles[idx] = cycle++;\n        pc_history[idx] = ip;\n        \n        // Detect sequential patterns\n        if (type == access_type::READ && \n            (instr_id - pc_history[idx]) <= 32) {\n            access_pattern[idx] = access_type::SEQUENTIAL;\n        }\n        \n        // Detect write-once patterns\n        if (type == access_type::WRITE && \n            !is_write_once(set, way)) {\n            bypass_candidate[idx] = true;\n        }\n    }\n}\n\nbool adaptive_phoenix::is_write_once(long set, long way) const {\n    auto idx = static_cast<std::size_t>(set * NUM_WAY + way);\n    return pc_history[idx] == 0 || \n           (access_pattern[idx] == access_type::WRITE && \n            (cycle - last_used_cycles[idx]) > 1000);\n}\n",
      "fitness": -Infinity,
      "parent_policies": [],
      "compilation_success": false,
      "metrics": {}
    },
    "pc_lru": {
      "name": "pc_lru",
      "code": "#include \"pc_lru.h\"\n#include <algorithm>\n#include <assert.h>\n\npc_lru::pc_lru(CACHE* cache) : pc_lru(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\npc_lru::pc_lru(CACHE* cache, long sets, long ways) : replacement(cache), NUM_WAY(ways) {\n    block_metadata.resize(static_cast<std::size_t>(sets * ways), {0, {}, 0});\n}\n\nlong pc_lru::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set,\n                        champsim::address ip, champsim::address full_addr, access_type type)\n{\n    const auto begin = block_metadata.begin() + (set * NUM_WAY);\n    const auto end = begin + NUM_WAY;\n    const uint64_t current_pc = ip.pcie();  // Get program counter\n\n    long victim_way = -1;\n    uint64_t min_utility = MAX_UTILITY;\n\n    // Find victim based on utility score and PC history\n    for (long way = 0; way < NUM_WAY; ++way) {\n        auto& meta = begin[way];\n        \n        // Calculate PC delta from previous accesses\n        uint64_t pc_delta = 0;\n        if (meta.pc_history[0] != 0) {\n            pc_delta = current_pc - meta.pc_history[0];\n        }\n\n        // Prefer victims with:\n        // 1. Low utility score\n        // 2. High PC delta (indicating temporal distance)\n        // 3. PC delta above threshold (likely to be non-reused)\n        if (meta.utility_score < min_utility ||\n            (pc_delta > PC_DELTA_THRESHOLD && meta.utility_score < MAX_UTILITY)) {\n            min_utility = meta.utility_score;\n            victim_way = way;\n        }\n\n        // If we find a block with PC delta above threshold, prefer it as victim\n        if (pc_delta > PC_DELTA_THRESHOLD) {\n            victim_way = way;\n            break;\n        }\n    }\n\n    // If no victim found with PC delta above threshold, fall back to LRU\n    if (victim_way == -1) {\n        auto victim = std::min_element(begin, end, [](const CacheBlockMetadata& a, const CacheBlockMetadata& b) {\n            return a.last_used_cycle < b.last_used_cycle;\n        });\n        victim_way = std::distance(begin, victim);\n    }\n\n    return victim_way;\n}\n\nvoid pc_lru::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr,\n                                    champsim::address ip, champsim::address victim_addr, access_type type)\n{\n    auto& meta = block_metadata.at(static_cast<std::size_t>(set * NUM_WAY + way));\n    meta.last_used_cycle = cycle++;\n    meta.pc_history[0] = ip.pcie();  // Store current PC\n\n    // Update utility score based on PC history\n    for (int i = 7; i > 0; --i) {\n        meta.pc_history[i] = meta.pc_history[i-1];\n    }\n    \n    // Calculate PC delta from previous access\n    uint64_t pc_delta = 0;\n    if (meta.pc_history[1] != 0) {\n        pc_delta = meta.pc_history[0] - meta.pc_history[1];\n    }\n\n    // Adjust utility score based on PC delta\n    meta.utility_score = std::min(MAX_UTILITY, meta.utility_score + pc_delta / 10);\n}\n\nvoid pc_lru::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr,\n                                     champsim::address ip, champsim::address victim_addr, access_type type,\n                                     uint8_t hit)\n{\n    if (hit && access_type{type} != access_type::WRITE) {  // Skip for writeback hits\n        auto& meta = block_metadata.at(static_cast<std::size_t>(set * NUM_WAY + way));\n        meta.last_used_cycle = cycle++;\n\n        // Update PC history and utility score on hit\n        meta.pc_history[0] = ip.pcie();\n        for (int i = 7; i > 0; --i) {\n            meta.pc_history[i] = meta.pc_history[i-1];\n        }\n\n        // Calculate PC delta\n        uint64_t pc_delta = 0;\n        if (meta.pc_history[1] != 0) {\n            pc_delta = meta.pc_history[0] - meta.pc_history[1];\n        }\n\n        // Adjust utility score based on PC delta\n        meta.utility_score = std::min(MAX_UTILITY, meta.utility_score + pc_delta / 10);\n    }\n}\n",
      "fitness": -Infinity,
      "parent_policies": [],
      "compilation_success": false,
      "metrics": {}
    },
    "lru_aura": {
      "name": "lru_aura",
      "code": "#include \"lru_aura.h\"\n#include <algorithm>\n#include <cassert>\n#include <map>\n\nusing namespace champsim::modules::replacement;\n\nlru_aura::lru_aura(CACHE* cache) : lru_aura(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nlru_aura::lru_aura(CACHE* cache, long sets, long ways) : replacement(cache), NUM_WAY(ways)\n{\n    // Initialize metadata for all cache blocks\n    metadata.resize(sets * ways);\n    for (auto& block : metadata) {\n        block.last_used_cycle = 0;\n        block.access_count = 0;\n    }\n}\n\nlong lru_aura::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set,\n                   champsim::address ip, champsim::address full_addr, access_type type)\n{\n    const auto begin = std::next(std::begin(metadata), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n    \n    // Find the best victim block using Aura's multi-criteria selection\n    auto victim = begin;\n    uint64_t max_score = 0;\n    \n    // Evaluate each block's potential as a victim candidate\n    for (auto it = begin; it < end; ++it) {\n        // Calculate a score based on inverse of various factors\n        uint64_t score = 0;\n        \n        // Prefer blocks with older last_used_cycle (temporal locality)\n        score += cycle - it->last_used_cycle;\n        \n        // Prefer blocks with lower access frequency (temporal stability)\n        score += (cycle / it->access_count) * 2;  // Weight frequency more heavily\n        \n        // Prefer blocks not associated with recent program counters\n        score += it->pc_access_count[ip] << 1;    // Weight PC history\n        \n        // Update victim if current block has higher score\n        if (score > max_score) {\n            max_score = score;\n            victim = it;\n        }\n    }\n    \n    // Calculate the victim way within the set\n    return std::distance(begin, victim);\n}\n\nvoid lru_aura::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr,\n                             champsim::address ip, champsim::address victim_addr, access_type type)\n{\n    const auto block_idx = set * NUM_WAY + way;\n    auto& block = metadata[block_idx];\n    \n    // Update metadata when a new block is inserted\n    block.last_used_cycle = cycle++;\n    block.access_count++;\n    \n    // Track program counter access patterns\n    block.pc_access_count[ip] = cycle++;\n}\n\nvoid lru_aura::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr,\n                               champsim::address ip, champsim::address victim_addr, access_type type, uint8_t hit)\n{\n    if (hit && type != access_type::WRITE) {  // Skip for writeback hits\n        const auto block_idx = set * NUM_WAY + way;\n        auto& block = metadata[block_idx];\n        \n        // Update metadata on cache hit\n        block.last_used_cycle = cycle++;\n        block.access_count++;\n        block.pc_access_count[ip] = cycle++;\n    }\n}\n",
      "fitness": -Infinity,
      "parent_policies": [],
      "compilation_success": false,
      "metrics": {}
    },
    "hybrid_adaptive_lru": {
      "name": "hybrid_adaptive_lru",
      "code": "#include \"hybrid_adaptive_lru.h\"\n#include <algorithm>\n#include <cassert>\n\nhybrid_adaptive_lru::hybrid_adaptive_lru(CACHE* cache, long sets, long ways, double weight)\n    : hybrid_adaptive_lru(cache, sets, ways) {\n    this->weight = weight;\n}\n\nhybrid_adaptive_lru::hybrid_adaptive_lru(CACHE* cache, double weight)\n    : replacement(cache), NUM_WAY(cache->NUM_WAY), weight(weight),\n      last_used_cycles(static_cast<std::size_t>(cache->NUM_SET * cache->NUM_WAY), 0),\n      frequency(static_cast<std::size_t>(cache->NUM_SET * cache->NUM_WAY), 0),\n      pc_histogram(static_cast<std::size_t>(cache->NUM_SET * cache->NUM_WAY), 0),\n      utility_score(static_cast<std::size_t>(cache->NUM_SET * cache->NUM_WAY), 0),\n      cycle(0) {}\n\nlong hybrid_adaptive_lru::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set,\n                                     const champsim::cache_block* current_set, champsim::address ip,\n                                     champsim::address full_addr, access_type type) {\n    const auto begin = std::next(std::begin(last_used_cycles), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n\n    // Calculate utility scores and combine with LRU information\n    for (auto it = begin; it != end; ++it) {\n        const auto index = std::distance(std::begin(last_used_cycles), it);\n        const auto recency = cycle - *it;\n        const auto inv_recency = static_cast<double>(recency) * 0.1; // Inverse relation\n        const auto inv_frequency = static_cast<double>(1.0 / (frequency[index] + 1));\n        const auto pc_weight = static_cast<double>(1.0 / (pc_histogram[index] + 1));\n        utility_score[index] = static_cast<uint64_t>(inv_recency + inv_frequency + pc_weight);\n    }\n\n    // Combine LRU and utility scores with dynamic weighting\n    auto begin_utility = std::begin(utility_score) + set * NUM_WAY;\n    auto end_utility = begin_utility + NUM_WAY;\n    auto begin_lru = begin;\n\n    // Custom comparator that combines LRU and utility scores\n    auto victim = std::min_element(begin, end, [begin_utility](const auto& a, const auto& b) {\n        const auto index_a = std::distance(std::begin(last_used_cycles), a);\n        const auto index_b = std::distance(std::begin(last_used_cycles), b);\n        const auto utility_a = *(begin_utility + index_a);\n        const auto utility_b = *(begin_utility + index_b);\n        // Combine LRU (lower value is better) and utility (lower value is better)\n        return ((*a + weight * utility_a) < (*b + weight * utility_b));\n    });\n\n    assert(begin <= victim);\n    assert(victim < end);\n    return std::distance(begin, victim);\n}\n\nvoid hybrid_adaptive_lru::replacement_cache_fill(uint32_t triggering_cpu, long set, long way,\n                                                champsim::address full_addr, champsim::address ip,\n                                                champsim::address victim_addr, access_type type) {\n    const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n    last_used_cycles[index] = cycle++;\n    frequency[index]++;\n    pc_histogram[index]++;\n    utility_score[index] = 0; // Reset utility score\n}\n\nvoid hybrid_adaptive_lru::update_replacement_state(uint32_t triggering_cpu, long set, long way,\n                                                   champsim::address full_addr, champsim::address ip,\n                                                   champsim::address victim_addr, access_type type,\n                                                   uint8_t hit) {\n    if (hit && access_type{type} != access_type::WRITE) { // Skip for writeback hits\n        const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n        last_used_cycles[index] = cycle++;\n        frequency[index]++;\n        pc_histogram[index]++;\n        utility_score[index] = 0; // Reset utility score\n    }\n}\n",
      "fitness": -Infinity,
      "parent_policies": [
        "adaptive_reuse",
        "lru_reference"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "lru_adaptive_frequency": {
      "name": "lru_adaptive_frequency",
      "code": "#include \"lru_adaptive_frequency.h\"\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nlru_adaptive_frequency::lru_adaptive_frequency(CACHE* cache, long sets, long ways)\n    : replacement(cache), NUM_WAY(ways), last_used_cycles(static_cast<std::size_t>(sets * ways), 0),\n      frequency(static_cast<std::size_t>(sets * ways), 0), pc_count(static_cast<std::size_t>(sets * ways), 0),\n      cycle(0) {}\n\nlong lru_adaptive_frequency::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set,\n                                        const champsim::cache_block* current_set, champsim::address ip,\n                                        champsim::address full_addr, access_type type) {\n    const auto begin = std::next(std::begin(last_used_cycles), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n\n    // Calculate utility scores for each way in the set\n    for (auto it = begin; it != end; ++it) {\n        const auto index = std::distance(std::begin(last_used_cycles), it);\n        const auto recency = cycle - *it;\n        const auto inv_recency = static_cast<double>(recency) * 0.2; // Higher weight for recency\n        const auto inv_frequency = static_cast<double>(1.0 / (frequency[index] + 1));\n        const auto pc_weight = static_cast<double>(1.0 / (pc_count[index] + 1));\n        *it = static_cast<uint64_t>(inv_recency + inv_frequency + pc_weight);\n    }\n\n    const auto victim = std::min_element(begin, end);\n    assert(begin <= victim);\n    assert(victim < end);\n    return std::distance(begin, victim);\n}\n\nvoid lru_adaptive_frequency::replacement_cache_fill(uint32_t triggering_cpu, long set, long way,\n                                                     champsim::address full_addr, champsim::address ip,\n                                                     champsim::address victim_addr, access_type type) {\n    const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n    last_used_cycles[index] = cycle++;\n    frequency[index]++;\n    pc_count[index]++;\n}\n\nvoid lru_adaptive_frequency::update_replacement_state(uint32_t triggering_cpu, long set, long way,\n                                                       champsim::address full_addr, champsim::address ip,\n                                                       champsim::address victim_addr, access_type type,\n                                                       uint8_t hit) {\n    if (hit && access_type{type} != access_type::WRITE) { // Skip for writeback hits\n        const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n        last_used_cycles[index] = cycle++;\n        frequency[index]++;\n        pc_count[index]++;\n    }\n}\n",
      "fitness": -Infinity,
      "parent_policies": [
        "adaptive_reuse",
        "lru_reference"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "hybrid_recency_frequency": {
      "name": "hybrid_recency_frequency",
      "code": "// hybrid_recency_frequency.cc\n\n#include \"hybrid_recency_frequency.h\"\n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nhybrid_recency_frequency::hybrid_recency_frequency(CACHE* cache) \n    : hybrid_recency_frequency(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nhybrid_recency_frequency::hybrid_recency_frequency(CACHE* cache, long sets, long ways, double decay)\n    : replacement(cache), NUM_WAY(ways), decay_factor(decay),\n      last_used_cycles(static_cast<std::size_t>(sets * ways), 0),\n      frequency(static_cast<std::size_t>(sets * ways), 0),\n      pc_histogram(static_cast<std::size_t>(sets * ways), 0),\n      utility_score(static_cast<std::size_t>(sets * ways), 0),\n      backup_way(static_cast<std::size_t>(sets), -1) {}\n\nlong hybrid_recency_frequency::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set,\n                                         const champsim::cache_block* current_set, champsim::address ip,\n                                         champsim::address full_addr, access_type type) {\n  const auto begin = std::next(std::begin(utility_score), set * NUM_WAY);\n  const auto end = std::next(begin, NUM_WAY);\n\n  // Calculate utility scores for each way in the set\n  for (auto it = begin; it != end; ++it) {\n    const auto index = std::distance(std::begin(utility_score), it);\n    const auto recency = cycle - last_used_cycles[index];\n    const auto freq = frequency[index];\n    const auto pc = pc_histogram[index];\n    \n    // Calculate utility score combining recency, frequency, and PC histogram\n    // Higher recency (older) reduces utility, higher frequency and PC increase utility\n    *it = static_cast<uint64_t>((1.0 / recency) + freq + pc);\n  }\n\n  const auto victim = std::min_element(begin, end);\n  assert(begin <= victim);\n  assert(victim < end);\n  return std::distance(begin, victim);\n}\n\nvoid hybrid_recency_frequency::replacement_cache_fill(uint32_t triggering_cpu, long set, long way,\n                                                       champsim::address full_addr, champsim::address ip,\n                                                       champsim::address victim_addr, access_type type) {\n  const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n  last_used_cycles[index] = cycle++;\n  \n  // Apply decay to frequency and PC histogram, then update\n  frequency[index] = frequency[index] * decay_factor + 1;\n  pc_histogram[index] = pc_histogram[index] * decay_factor + 1;\n  utility_score[index] = 0;  // Reset utility score\n}\n\nvoid hybrid_recency_frequency::update_replacement_state(uint32_t triggering_cpu, long set, long way,\n                                                        champsim::address full_addr, champsim::address ip,\n                                                        champsim::address victim_addr, access_type type,\n                                                        uint8_t hit) {\n  if (hit && access_type{type} != access_type::WRITE) {  // Skip for writeback hits\n    const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n    last_used_cycles[index] = cycle++;\n    \n    // Apply decay to frequency and PC histogram, then update\n    frequency[index] = frequency[index] * decay_factor + 1;\n    pc_histogram[index] = pc_histogram[index] * decay_factor + 1;\n    utility_score[index] = 0;  // Reset utility score\n  }\n}\n",
      "fitness": -Infinity,
      "parent_policies": [
        "lru_reference",
        "adaptive_reuse"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "hybridreuse": {
      "name": "hybridreuse",
      "code": "#include \"hybridreuse.h\"\n\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nhybridreuse::hybridreuse(CACHE* cache) : hybridreuse(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nhybridreuse::hybridreuse(CACHE* cache, long sets, long ways) : \n    replacement(cache), \n    NUM_WAY(ways),\n    last_used_cycles(static_cast<std::size_t>(sets * ways), 0),\n    frequency(static_cast<std::size_t>(sets * ways), 0),\n    pc_histogram(static_cast<std::size_t>(sets * ways), 0),\n    utility_score(static_cast<std::size_t>(sets * ways), 0),\n    backup_way(static_cast<std::size_t>(sets), -1),\n    cycle(0),\n    temperature(1000.0) {\n        // High initial temperature for exploration\n    }\n\nlong hybridreuse::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, \n                              const champsim::cache_block* current_set, champsim::address ip,\n                              champsim::address full_addr, access_type type) {\n    const auto begin = std::next(std::begin(utility_score), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n\n    // Calculate utility scores with temperature-based weights\n    for (auto it = begin; it != end; ++it) {\n        const auto index = std::distance(std::begin(utility_score), it);\n        const auto recency = static_cast<double>(cycle - last_used_cycles[index]);\n        const auto inv_recency = recency * 0.1; // Inverse relation\n        \n        const auto freq_weight = static_cast<double>(1.0 / (frequency[index] + 1));\n        const auto pc_weight = static_cast<double>(1.0 / (pc_histogram[index] + 1));\n        \n        // Temperature-based weight adjustment\n        const auto temperature_weight = std::exp(-recency / temperature);\n        \n        // Combined utility score\n        *it = static_cast<uint64_t>(inv_recency * temperature_weight + \n                                   freq_weight * (1 - temperature_weight) + \n                                   pc_weight * (1 - temperature_weight));\n    }\n\n    const auto victim = std::min_element(begin, end);\n    assert(begin <= victim);\n    assert(victim < end);\n    return std::distance(begin, victim);\n}\n\nvoid hybridreuse::replacement_cache_fill(uint32_t triggering_cpu, long set, long way,\n                                        champsim::address full_addr, champsim::address ip,\n                                        champsim::address victim_addr, access_type type) {\n    const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n    last_used_cycles[index] = cycle++;\n    frequency[index]++;\n    pc_histogram[index]++;\n    utility_score[index] = 0; // Reset utility score\n    \n    // Gradually decrease temperature for exploitation\n    temperature *= 0.9999;\n}\n\nvoid hybridreuse::update_replacement_state(uint32_t triggering_cpu, long set, long way,\n                                         champsim::address full_addr, champsim::address ip,\n                                         champsim::address victim_addr, access_type type, uint8_t hit) {\n    if (hit && access_type{type} != access_type::WRITE) { // Skip for writeback hits\n        const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n        last_used_cycles[index] = cycle++;\n        frequency[index]++;\n        pc_histogram[index]++;\n        utility_score[index] = 0; // Reset utility score\n        \n        // Gradually decrease temperature for exploitation\n        temperature *= 0.9999;\n    }\n}\n",
      "fitness": -Infinity,
      "parent_policies": [
        "lru_reference",
        "adaptive_reuse"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "frec": {
      "name": "frec",
      "code": "#include \"frec.h\"\n#include <algorithm>\n#include <cassert>\n\nfrec::frec(CACHE* cache) : frec(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nfrec::frec(CACHE* cache, long sets, long ways) : replacement(cache), NUM_SET(sets), NUM_WAY(ways), \n                                                last_used_cycles(static_cast<std::size_t>(sets * ways), 0),\n                                                access_frequency(static_cast<std::size_t>(sets * ways), 0),\n                                                cycle(0)\n{\n}\n\nlong frec::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set,\n                      champsim::address ip, champsim::address full_addr, access_type type)\n{\n    const auto begin = std::next(std::begin(last_used_cycles), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n    \n    // Find the block with the lowest access frequency (cold block)\n    auto begin_freq = std::next(std::begin(access_frequency), set * NUM_WAY);\n    auto end_freq = std::next(begin_freq, NUM_WAY);\n    \n    auto victim = std::min_element(begin_freq, end_freq, [](uint64_t a, uint64_t b) {\n        return a < b;\n    });\n    \n    // If multiple blocks have the same frequency, fall back to LRU\n    if (std::distance(begin_freq, std::find(end_freq, *begin_freq, *begin_freq)) > 1) {\n        auto victim_lru = std::min_element(begin, end);\n        return std::distance(begin, victim_lru);\n    }\n    \n    return std::distance(begin, victim);\n}\n\nvoid frec::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr,\n                                 champsim::address ip, champsim::address victim_addr, access_type type)\n{\n    access_frequency.at((std::size_t)(set * NUM_WAY + way))++;\n    last_used_cycles.at((std::size_t)(set * NUM_WAY + way)) = cycle++;\n}\n\nvoid frec::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr,\n                                   champsim::address ip, champsim::address victim_addr, access_type type,\n                                   uint8_t hit)\n{\n    if (hit && access_type{type} != access_type::WRITE) {\n        access_frequency.at((std::size_t)(set * NUM_WAY + way))++;\n        last_used_cycles.at((std::size_t)(set * NUM_WAY + way)) = cycle++;\n    }\n}\n",
      "fitness": null,
      "parent_policies": [
        "lru_reference"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "lru_aging": {
      "name": "lru_aging",
      "code": "#include \"lru_aging.h\"\n\n#include <algorithm>\n#include <cassert>\n\nlru_aging::lru_aging(CACHE* cache, long sets, long ways) : replacement(cache), cycle(0), age_interval(1000), age_amount(1000), last_aging_cycle(0) {\n    if (sets == -1)\n        sets = cache->NUM_SET;\n    if (ways == -1)\n        ways = cache->NUM_WAY;\n    last_used_cycles.resize(sets * ways, 0);\n}\n\nlru_aging::~lru_aging() {}\n\nlong lru_aging::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set, champsim::address ip, champsim::address full_addr, access_type type) {\n    const auto begin = std::next(last_used_cycles.begin(), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n\n    // Check if it's time to age the last_used_cycles\n    if (cycle - last_aging_cycle >= age_interval) {\n        for (auto it = last_used_cycles.begin(); it != last_used_cycles.end(); ++it) {\n            if (*it > age_amount)\n                *it -= age_amount;\n            else\n                *it = 0;\n        }\n        last_aging_cycle = cycle;\n    }\n\n    const auto victim = std::min_element(begin, end);\n    assert(begin <= victim);\n    assert(victim < end);\n    return std::distance(begin, victim);\n}\n\nvoid lru_aging::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip, champsim::address victim_addr, access_type type) {\n    last_used_cycles.at(static_cast<std::size_t>(set * NUM_WAY + way)) = cycle++;\n}\n\nvoid lru_aging::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip, champsim::address victim_addr, access_type type, uint8_t hit) {\n    if (hit && type != access_type::WRITE) {\n        last_used_cycles.at(static_cast<std::size_t>(set * NUM_WAY + way)) = cycle++;\n    }\n}\n",
      "fitness": null,
      "parent_policies": [
        "lru_reference"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "swbok": {
      "name": "swbok",
      "code": "#include \"swbok.h\"\n#include <algorithm>\n#include <cassert>\n#include <queue>\n\nswbok::swbok(CACHE* cache) : swbok(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nswbok::swbok(CACHE* cache, long sets, long ways) : replacement(cache), NUM_SET(sets), NUM_WAY(ways),\n                                                   last_used_cycles(sets * ways, 0),\n                                                   last_used_window(sets * ways, 0),\n                                                   frequency(sets * ways, 0),\n                                                   window_size(100),  // Adjustable parameter\n                                                   victim_way(-1), cycle(0) {}\n\nlong swbok::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set, champsim::address ip,\n                       champsim::address full_addr, access_type type)\n{\n    const auto begin = std::next(std::begin(last_used_cycles), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n\n    // Victim selection using sliding window and frequency\n    auto victim = begin;\n    uint64_t min_score = std::numeric_limits<uint64_t>::max();\n\n    for (auto it = begin; it != end; ++it)\n    {\n        const auto index = std::distance(begin, it);\n        const auto way = index + set * NUM_WAY;\n\n        // Calculate score: Combine recency and frequency\n        uint64_t score = (cycle - *it) + (window_size - last_used_window[way]) + frequency[way] * 2;\n\n        if (score < min_score)\n        {\n            min_score = score;\n            victim = it;\n        }\n    }\n\n    // Keep track of victim to reduce thrashing\n    victim_way = std::distance(begin, victim);\n    return victim_way;\n}\n\nvoid swbok::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip, champsim::address victim_addr,\n                                 access_type type)\n{\n    const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n    last_used_cycles[index] = cycle++;\n    last_used_window[index] = cycle % window_size;  // Update sliding window\n    frequency[index]++;  // Track access frequency\n}\n\nvoid swbok::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip,\n                                   champsim::address victim_addr, access_type type, uint8_t hit)\n{\n    if (hit && type != access_type::WRITE)\n    {\n        const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n        last_used_cycles[index] = cycle++;\n        last_used_window[index] = cycle % window_size;\n        frequency[index]++;  // Update frequency on hit\n    }\n\n    // If victim is accessed again, promote it\n    if (victim_way != -1)\n    {\n        const auto victim_index = static_cast<std::size_t>(set * NUM_WAY + victim_way);\n        if (victim_addr == full_addr)\n        {\n            last_used_cycles[victim_index] = cycle++;\n            last_used_window[victim_index] = cycle % window_size;\n            frequency[victim_index]++;  // Update frequency for victim\n        }\n    }\n}\n",
      "fitness": null,
      "parent_policies": [
        "lru_reference"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "frequent_lru": {
      "name": "frequent_lru",
      "code": "#include \"frequent_lru.h\"\n\n#include <algorithm>\n#include <cassert>\n\nfrequent_lru::frequent_lru(CACHE* cache) : frequent_lru(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nfrequent_lru::frequent_lru(CACHE* cache, long sets, long ways)\n    : replacement(cache), NUM_SET(sets), NUM_WAY(ways),\n      last_used_cycles(static_cast<std::size_t>(sets * ways), 0),\n      access_frequency(static_cast<std::size_t>(sets * ways), 0),\n      cycle(0) {}\n\nlong frequent_lru::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set,\n                               const champsim::cache_block* current_set, champsim::address ip,\n                               champsim::address full_addr, access_type type) {\n    const auto begin = std::next(std::begin(last_used_cycles), set * NUM_WAY);\n    const auto end = std::next(begin, NUM_WAY);\n\n    // Find the block with the lowest access frequency\n    auto victim = std::min_element(begin, end, [this](const uint64_t& a, const uint64_t& b) {\n        return access_frequency[a - begin] < access_frequency[b - begin];\n    });\n\n    // Among blocks with the same frequency, choose the one with the oldest last_used_cycle\n    if (victim != end) {\n        auto first = victim;\n        for (++victim; victim != end; ++victim) {\n            if (access_frequency[victim - begin] == access_frequency[first - begin] &&\n                last_used_cycles[victim - begin] < last_used_cycles[first - begin]) {\n                first = victim;\n            }\n        }\n        victim = first;\n    }\n\n    return std::distance(begin, victim);\n}\n\nvoid frequent_lru::replacement_cache_fill(uint32_t triggering_cpu, long set, long way,\n                                         champsim::address full_addr, champsim::address ip,\n                                         champsim::address victim_addr, access_type type) {\n    const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n    access_frequency[index]++;\n    last_used_cycles[index] = cycle++;\n}\n\nvoid frequent_lru::update_replacement_state(uint32_t triggering_cpu, long set, long way,\n                                           champsim::address full_addr, champsim::address ip,\n                                           champsim::address victim_addr, access_type type,\n                                           uint8_t hit) {\n    if (hit && access_type{type} != access_type::WRITE) { // Skip writeback hits\n        const auto index = static_cast<std::size_t>(set * NUM_WAY + way);\n        access_frequency[index]++;\n        last_used_cycles[index] = cycle++;\n    }\n}\n",
      "fitness": null,
      "parent_policies": [
        "lru_reference"
      ],
      "compilation_success": false,
      "metrics": {}
    },
    "lru_frequency": {
      "name": "lru_frequency",
      "code": "#include \"lru_frequency.h\"\n\n#include <algorithm>\n#include <cassert>\n\nlru_frequency::lru_frequency(CACHE* cache) : lru_frequency(cache, cache->NUM_SET, cache->NUM_WAY) {}\n\nlru_frequency::lru_frequency(CACHE* cache, long sets, long ways) : replacement(cache), last_used_cycles(static_cast<std::size_t>(sets * ways)), MAX_FREQUENCY(1000) {\n    cycle = 0;\n    for (auto& info : last_used_cycles) {\n        info.last_used = 0;\n        info.frequency = 0;\n    }\n}\n\nlong lru_frequency::find_victim(uint32_t triggering_cpu, uint64_t instr_id, long set, const champsim::cache_block* current_set, champsim::address ip,\n                              champsim::address full_addr, access_type type)\n{\n    const auto set_start = set * NUM_WAY;\n    const auto set_end = set_start + NUM_WAY;\n    size_t victim_way = 0;\n    uint64_t max_score = 0;\n\n    for (size_t way = set_start; way < set_end; ++way) {\n        const auto& info = last_used_cycles[way];\n        const uint64_t time_since = cycle - info.last_used;\n        const uint32_t frequency = MAX_FREQUENCY - info.frequency;\n        const uint64_t score = time_since + frequency;\n\n        if (score > max_score) {\n            max_score = score;\n            victim_way = way;\n        }\n    }\n\n    return victim_way - set_start;\n}\n\nvoid lru_frequency::replacement_cache_fill(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip,\n                                  champsim::address victim_addr, access_type type)\n{\n    const size_t way_idx = static_cast<size_t>(set * NUM_WAY + way);\n    last_used_cycles[way_idx].last_used = cycle++;\n    last_used_cycles[way_idx].frequency = 1; // Reset frequency when filled\n}\n\nvoid lru_frequency::update_replacement_state(uint32_t triggering_cpu, long set, long way, champsim::address full_addr, champsim::address ip,\n                                   champsim::address victim_addr, access_type type, uint8_t hit)\n{\n    if (hit && access_type{type} != access_type::WRITE) { // Skip for writeback hits\n        const size_t way_idx = static_cast<size_t>(set * NUM_WAY + way);\n        last_used_cycles[way_idx].last_used = cycle++;\n        last_used_cycles[way_idx].frequency++;\n    }\n}\n",
      "fitness": null,
      "parent_policies": [
        "lru_reference"
      ],
      "compilation_success": false,
      "metrics": {}
    }
  }
}